import asyncio
import os
import re
import uuid
import traceback
from telegram import Update, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from transformers import pipeline, MBartForConditionalGeneration, MBart50TokenizerFast
import whisper
from fpdf import FPDF
import yt_dlp
from dotenv import load_dotenv

# Load .env file
load_dotenv()

# Get token from environment
BOT_TOKEN = os.getenv("BOT_TOKEN")

if not BOT_TOKEN:
    raise RuntimeError("‚ùå BOT_TOKEN is not set in environment")

print("‚è≥ Loading models... (first time may take a while)")

# Load models
summarizer_en = pipeline("summarization", model="facebook/bart-large-cnn")
tokenizer_ml = MBart50TokenizerFast.from_pretrained("facebook/mbart-large-50-many-to-many-mmt")
model_ml = MBartForConditionalGeneration.from_pretrained("facebook/mbart-large-50-many-to-many-mmt")
whisper_model = whisper.load_model("base")

print("‚úÖ Models loaded successfully!")

user_sessions = {}

def download_audio(video_url: str) -> str:
    temp_file = f"temp_{uuid.uuid4().hex}"
    ydl_opts = {
        "format": "bestaudio/best",
        "outtmpl": temp_file,
        "postprocessors": [{"key": "FFmpegExtractAudio", "preferredcodec": "mp3", "preferredquality": "192"}],
        "quiet": True,
        "noplaylist": True
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([video_url])
    actual_file = temp_file + ".mp3"
    if not os.path.exists(actual_file):
        raise Exception(f"Audio download failed: {actual_file} does not exist")
    return actual_file

def get_transcript(video_url: str):
    audio_file = download_audio(video_url)
    try:
        result = whisper_model.transcribe(audio_file)
        transcript = result.get("text", "")
        lang = "ml" if result.get("language", "en").startswith("ml") else "en"
    finally:
        if os.path.exists(audio_file):
            os.remove(audio_file)
    if not transcript.strip():
        raise Exception("Failed to extract transcript ‚ùå")
    return transcript.strip(), lang

def summarize_en_text(text: str):
    chunks = [text[i:i+1000] for i in range(0, len(text), 1000)]
    summary = []
    for chunk in chunks:
        try:
            summary.append(summarizer_en(chunk, max_length=120, min_length=30, do_sample=False)[0]["summary_text"])
        except:
            summary.append(chunk[:300])
    return " ".join(summary).strip()

def translate_ml_to_en(text: str):
    tokenizer_ml.src_lang = "ml_IN"
    inputs = tokenizer_ml(text, return_tensors="pt", max_length=1024, truncation=True)
    translated_ids = model_ml.generate(
        inputs["input_ids"], max_length=1024, num_beams=4,
        forced_bos_token_id=tokenizer_ml.lang_code_to_id["en_XX"]
    )
    return tokenizer_ml.decode(translated_ids[0], skip_special_tokens=True)

def extract_keypoints(summary: str, max_points: int = 8):
    sentences = re.split(r'(?<=[\.\?\!])\s+', summary)
    sentences = [s.strip() for s in sentences if len(s.strip())>25]
    if not sentences:
        sentences = [summary[i:i+120].strip() for i in range(0,len(summary),120)]
    return sentences[:max_points]

def make_pdf(title: str, summary: str, keypoints: list[str], filename: str):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)


    pdf.add_page()
    pdf.set_font("Arial", "B", 20)
    pdf.cell(0, 20, title[:120], ln=True, align="C")
    pdf.ln(10)
    pdf.set_font("Arial", "I", 12)
    pdf.multi_cell(0, 8, "This PDF contains a summarized version of the YouTube video along with key points.", align="C")


    pdf.add_page()
    pdf.set_font("Arial", "B", 16)
    pdf.cell(0, 10, "Summary", ln=True)
    pdf.ln(5)
    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 7, summary)


    if keypoints:
        pdf.ln(8)
        pdf.set_font("Arial", "B", 16)
        pdf.cell(0, 10, "Key Points", ln=True)
        pdf.ln(3)
        pdf.set_font("Arial", "", 12)
        for idx, kp in enumerate(keypoints, start=1):
            pdf.multi_cell(0, 7, f"- {kp}")
            pdf.ln(1)

    # Footer
    pdf.set_auto_page_break(auto=False)
    pdf.set_y(-15)
    pdf.set_font("Arial", "I", 8)
    pdf.cell(0, 6, "Generated by YouTube Summarizer Bot", ln=True, align="C")

    pdf.output(filename)

async def send_long_message_safe(bot, chat_id: int, text: str):
    if not text.strip():
        return
    text = re.sub(r"<[^>]+>", "", text)
    text = "".join(ch if ch.isprintable() else " " for ch in text)
    max_len = 3800
    try:
        for i in range(0, len(text), max_len):
            chunk = text[i:i+max_len].strip()
            if chunk:
                await bot.send_message(chat_id=chat_id, text=chunk)
    except Exception:
        try:
            await bot.send_message(chat_id=chat_id, text="(Error sending full text, see PDF)")
        except Exception:
            pass

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user_sessions[chat_id] = True
    await update.message.reply_text(
        "üëã Hi! Send me a YouTube link (English/Malayalam). I will summarize it and generate a PDF.\nType /help to see commands."
    )
async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "active_process" in context.user_data and context.user_data["active_process"] != "idle":
        last_task = context.user_data["active_process"]
        context.user_data["active_process"] = "idle"  # Reset ‚Üí stops handle_message
        await update.message.reply_text(f"‚ùå The last operation **{last_task}** was cancelled.")
    else:
        await update.message.reply_text("‚ö†Ô∏è No active operation to cancel.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "/start - Start bot\n"
        "/help - Show commands\n"
        "/steps - Show steps bot performs\n"
        "/summary Just send youtubelink - Get PDF summary\n"
        "/clear - Clear bot messages\n"
        "/cancel- Cancel the last operation\n"
    )
    await update.message.reply_text(text)

async def steps_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "Bot Steps:\n"
        "1. Download YouTube audio\n"
        "2. Transcribe using Whisper\n"
        "3. Detect language\n"
        "4. Translate if Malayalam\n"
        "5. Summarize\n"
        "6. Extract key points\n"
        "7. Generate PDF\n"
        "8. Send PDF to user"
    )
    await update.message.reply_text(text)

async def clear_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üßπ Clearing chat mess ages is not fully supported in all Telegram clients.")

# --- inside handle_message ---
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if not user_sessions.get(chat_id):
        await update.message.reply_text("‚ö†Ô∏è Please type /start to begin.")
        return

    url = update.message.text.strip()
    if "youtube.com" not in url and "youtu.be" not in url:
        await update.message.reply_text("‚ö†Ô∏è Please send a valid YouTube link.")
        return

    # mark process as active
    context.user_data["active_process"] = "summarizing"

    await context.bot.send_message(chat_id, "üì• Fetching transcript... Please wait ‚è≥")
    try:
        # check cancellation before each heavy step
        if context.user_data.get("active_process") == "idle":
            await context.bot.send_message(chat_id, "‚ùå Operation cancelled.")
            return

        transcript, lang = await asyncio.to_thread(get_transcript, url)

        if context.user_data.get("active_process") == "idle":
            await context.bot.send_message(chat_id, "‚ùå Operation cancelled.")
            return

        await context.bot.send_message(chat_id, "üìù Summarizing...")

        if lang == "en":
            summary = await asyncio.to_thread(summarize_en_text, transcript)
        else:
            translated = await asyncio.to_thread(translate_ml_to_en, transcript)
            summary = await asyncio.to_thread(summarize_en_text, translated)

        if context.user_data.get("active_process") == "idle":
            await context.bot.send_message(chat_id, "‚ùå Operation cancelled.")
            return

        await send_long_message_safe(context.bot, chat_id, "Summary:\n\n" + summary)
        keypoints = extract_keypoints(summary)

        pdf_file = f"summary_{uuid.uuid4().hex}.pdf"
        await asyncio.to_thread(make_pdf, "YouTube Summary", summary, keypoints, pdf_file)

        if context.user_data.get("active_process") == "idle":
            os.remove(pdf_file)
            await context.bot.send_message(chat_id, "‚ùå Operation cancelled.")
            return

        with open(pdf_file, "rb") as f:
            await context.bot.send_document(chat_id, f, filename="summary.pdf", caption="PDF with key points")

        os.remove(pdf_file)

    except Exception as e:
        await context.bot.send_message(chat_id, f"‚ùå Error: {e}")
        print(traceback.format_exc())
    finally:
        context.user_data["active_process"] = "idle"  # reset state

def main():
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("steps", steps_command))
    app.add_handler(CommandHandler("clear", clear_command))
    app.add_handler(CommandHandler("cancel", cancel_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("üöÄ Bot running...")
    app.run_polling()

if __name__ == "__main__":
    main()
